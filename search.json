[{"title":"Json序列化","url":"/2021/12/03/test/","content":"​     对于跨语言传输数据，可利用一套规范——Json，可以将数据类型给Json序列化，传输到其他地方，再进行反序列化，就可以解析出信息。\n​        例如web的b/s应用中，在web服务器中写入（golang规范），进行Json序列化，在传输过程中，会遵守Json规范——这是一套比较科学的规范，将数据传入浏览器，再讲Json字符串进行反序列化，得到原先数据类型的内容，将其规范到使用的语言中。\n​        Json序列化其实就是将数据规范成：键值对的形式\n​        在golang中，序列化需要的包：encoding/json\n​        序列化需要的方法： *json.Marshal(interface{})([]byte , nil error) \n​        方法说明：参数是一个空接口，就代表可以接收任意类型的数据，返回值为byte类型切片，在实际应用中，大多数要将切片转化成string ， 还返回一个空指针，可以用一个值来接收这个空指针，若返回的非空指针，则说明序列化失败！\nTag的应用​        在实际应用中，若要将一个struct Json化，如图Monster结构体\n![image-20211110165821114](C:\\Users\\The shy\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211110165821114.png)\n若是将该结构体Json序列化，得到：\n{“Name”:”Jack”,”Age”:”52”,”Id”:”123”}\n传输进的Json码原样传输，所以我们可以在编码时候加入如图的Tag转化，这样就会替换为json冒号后的东西。\n{“name”:”Jack”,”age”:”52”,”Id”:”123”}序列化成功，并且用了tag标签化！\n（下面附上golang测试代码）\npackage mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;)type Monster struct &#123;\tName string `json:&quot;name&quot;` \tAge string `json:&quot;age&quot;`\tId  string&#125;func main() &#123;\tvar monster Monster\tmonster = Monster&#123;\t\tName: &quot;Jack&quot;,\t\tAge: &quot;52&quot;,\t\tId: &quot;123&quot;,\t&#125;\tdata , err := json.Marshal(monster)\tif err != nil&#123;\t\tfmt.Println(&quot;序列化失败了！&quot;)\t&#125;else &#123;\t\tfmt.Println(string(data))\t\tfmt.Println(&quot;序列化成功，并且用了tag标签化！&quot;)\t&#125;&#125;\n\n反序列化在项目开发中，一般接收数据库或者网络输入的Json字串，我们将对其进行反序列化。\n在golang中，利用unMarshal方法对其进行反序列化操作。\n先来看看方法的定义：func  unMarshal([]byte , interface{}) error \n参数：传入一个byte切片，和一个任意类型，其实就是要转化的类型，要跟Json串对应上。\n返回值：返回一个error指针，也就是空指针，可以加个判断，若返回的不是nil 则说明反序列化失败！\n测试代码如下：\npackage mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;)//反序列化操作type Monster struct &#123;\tName string `json:&quot;name&quot;`\tAge string `json:&quot;age&quot;`\tId  string&#125;func unserialization()&#123;\tvar monster Monster\tstr := &quot;&#123;\\&quot;name\\&quot;:\\&quot;Jack\\&quot;,\\&quot;age\\&quot;:\\&quot;52\\&quot;,\\&quot;Id\\&quot;:\\&quot;123\\&quot;&#125;&quot;\terr := json.Unmarshal([]byte(str),&amp;monster)\tif err != nil&#123;\t\tfmt.Println(&quot;反序列化失败！&quot;)\t&#125;else &#123;\t\tfmt.Println(&quot;反序列化成功&quot;)\t\tfmt.Println(monster)\t&#125;&#125;func main() &#123;\tunserialization()&#125;\n\n输出：\n反序列化成功{Jack 52 123}\n在测试代码中，我使用了一个普通的字符串，但是在实际开发项目中，接收的Json字串是来自于网络传输和文件传输。反序列化的底层是利用了反射的原理，反射在后面会学到！\n","categories":["技术"],"tags":["golang","网络编程"]}]