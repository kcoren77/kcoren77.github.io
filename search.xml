<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面向对象初探--基于C++(2)</title>
    <url>/2021/12/07/C++%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="C-继承"><a href="#C-继承" class="headerlink" title="C++继承"></a>C++继承</h2><p>继承是面向对象设计中很重要的一个环节，当要定义一个类时，但是已经存在一个类成员或者类成员函数都是你需要的，那么你再写一个类就会花掉大量功夫，所以引出<strong>继承</strong>的概念。<br>继承——就是在已有类的基础上新建一个类，这个类可以继承<strong>基类</strong>的成员或者成员函数。<br>那么什么是基类呢？基类就是已有的类，也叫<strong>父类</strong>新创建的那个类叫做<strong>派生类</strong>，也叫<strong>子类</strong>。<br>下面来看看一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个shape类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> g)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> width;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::setWidth</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  width = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::setHeight</span><span class="params">(<span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">  height = g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个rectangle继承Shape类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rectangle::getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> width * height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Rectangle ret; <span class="comment">// 一个对象</span></span><br><span class="line">  ret.<span class="built_in">setWidth</span>(<span class="number">10</span>);</span><br><span class="line">  ret.<span class="built_in">setHeight</span>(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; ret.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析代码：<br>先是定义了一个Shape类，然后又定义了一个Rectangle类去继承Shape类，注意继承的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">  <span class="comment">// 内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到写了一个 <strong>public</strong> ，表明是 <strong>public</strong> 类型的继承。<br>问题又来了，那是不是有 <strong>protected</strong> 和<strong>private</strong> 类型的继承呢？<br>答案是肯定的。<br>下面来分析分析三种继承方式的区别：<br><strong>public ：派生类可以访问基类的公有和保护成员，但是不能访问私有成员！</strong><br><strong>protected : 派生类可以继承基类的公有和保护成员，将其变成自己的保护成员！</strong><br><strong>private : 将基类的公有和保护成员变成自己的私有成员！</strong><br>上面就是三种继承方式，可以看出，派生类可以访问基类的<strong>公有成员</strong>和<strong>保护成员</strong>，私有成员神圣不可侵犯！<br>还要注意，一个派生类继承了所有的基类方法，但下列情况除外：<br><strong>基类的构造函数、析构函数和拷贝构造函数。</strong><br><strong>基类的重载运算符</strong><br><strong>基类的友元函数</strong><br>又会有疑问了，什么是重载运算符，什么是友元函数？<br>这个后面再说。<br>先来分析继承的三种方式的特点，结合代码来分析。  </p>
<h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><p>先来看看一个重要的归纳：<br><strong>(1) private成员只能被本类成员和友元访问，不能被其他访问。</strong><br><strong>(2) protected成员可以被派生类访问。</strong>  </p>
<h3 id="public继承"><a href="#public继承" class="headerlink" title="public继承"></a>public继承</h3><p>先看下面一段代码  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">A</span>()&#123;</span><br><span class="line">    a1 = <span class="number">1</span>;</span><br><span class="line">    a2 = <span class="number">2</span>;</span><br><span class="line">    a3 = <span class="number">3</span>;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;    <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> a2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">B</span>(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    a = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;       <span class="comment">//正确，public成员</span></span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; endl;       <span class="comment">//正确，基类的public成员，在派生类中仍是public成员。</span></span><br><span class="line">    cout &lt;&lt; a2 &lt;&lt; endl;       <span class="comment">//正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。</span></span><br><span class="line">    cout &lt;&lt; a3 &lt;&lt; endl;       <span class="comment">//错误，基类的private成员不能被派生类访问。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; b.a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; b.a1 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">  cout &lt;&lt; b.a2 &lt;&lt; endl;   <span class="comment">//错误，类外不能访问protected成员</span></span><br><span class="line">  cout &lt;&lt; b.a3 &lt;&lt; endl;   <span class="comment">//错误，类外不能访问private成员</span></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来分析代码，复习一下，public继承的内容是啥：基类的<strong>public</strong>和<strong>protected</strong>成员在派生类中变成派生类的<strong>public成员</strong> 和 <strong>protected 成员</strong>。<br>然后来看代码，先是定义了一个<strong>A类</strong>，里面的构造函数为4个变量赋值，没毛病吧，注意变量的类型有不相同，在A类中的成员函数 <strong>fun()</strong> 可以轻松访问4个变量，没毛病吧。然后定义一个<strong>B类</strong>，使用public继承，在B类的构造函数里面调用A的构造函数，为啥可以调用呢？因为A类的构造函数是pubic类型的成员函数，注意一个细节，默认的构造函数是private类型的，在这里特意声明为public！回到主题，既然是public类型，那么被B类继承下来，就变成B类的public成员函数了，当然可以调用！<br>然后下面的就不用多说，在B类里面的fun成员函数，可以访问a，a1，a2因为public继承会让基类的public和protected变成自己的public和protected，当然可以访问。<br>main函数中就不多说，public成员可以直接访问，protected和private成员相似，类外不能直接访问！  </p>
<h3 id="protected继承"><a href="#protected继承" class="headerlink" title="protected继承"></a>protected继承</h3><p>其实明白道理就差不多，protected继承，<strong>让基类的public成员和protected成员都变成自己的protected成员</strong>  </p>
<h3 id="private继承"><a href="#private继承" class="headerlink" title="private继承"></a>private继承</h3><p><strong>就是让基类的都变成自己的private成员！</strong>  </p>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>先来明白多继承的概念：<br>多继承就是<strong>一个子类可以有多个父类</strong><br>继承特点上面已经说过了，带入使用即可。<br>基本继承语法如下：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Rectangle使用public继承方式继承Shape类和PainCost类。</strong>  </p>
<p>———结语：我们都不知道未来如何，只能一路前进！———</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象思想</tag>
      </tags>
  </entry>
  <entry>
    <title>Json介绍--基于Golang</title>
    <url>/2021/12/05/Json%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#序列化<br>​        对于跨语言传输数据，可利用一套规范——Json，可以将数据类型给Json序列化，传输到其他地方，再进行反序列化，就可以解析出信息。</p>
<p>​        例如web的b/s应用中，在web服务器中写入（golang规范），进行Json序列化，在传输过程中，会遵守Json规范——这是一套比较科学的规范，将数据传入浏览器，再讲Json字符串进行反序列化，得到原先数据类型的内容，将其规范到使用的语言中。</p>
<p>​        Json序列化其实就是将数据规范成：<strong>键值对</strong>的形式</p>
<p>​        在golang中，序列化需要的包：<strong>encoding/json</strong></p>
<p>​        序列化需要的方法： *<em>json.Marshal(interface{})([]byte , nil <em>error)</em></em> </p>
<p>​        方法说明：参数是一个空接口，就代表可以接收任意类型的数据，返回值为byte类型切片，在实际应用中，大多数要将切片转化成string ， 还返回一个空指针，可以用一个值来接收这个空指针，若返回的非空指针，则说明序列化失败！</p>
<h5 id="Tag的应用"><a href="#Tag的应用" class="headerlink" title="Tag的应用"></a>Tag的应用</h5><p>​        在实际应用中，若要将一个struct Json化，如图Monster结构体</p>
<p><img src="/2021/12/05/Json%E5%BA%8F%E5%88%97%E5%8C%96/01.png" alt=" "></p>
<p>若是将该结构体Json序列化，得到：</p>
<p><strong>{“Name”:”Jack”,”Age”:”52”,”Id”:”123”}</strong></p>
<p>传输进的Json码原样传输，所以我们可以在编码时候加入如图的Tag转化，这样就会替换为json冒号后的东西。</p>
<p><strong>{“name”:”Jack”,”age”:”52”,”Id”:”123”}</strong><br><strong>序列化成功，并且用了tag标签化！</strong></p>
<p>（下面附上golang测试代码）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line"> 	Age <span class="keyword">string</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Id  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	monster = Monster&#123;</span><br><span class="line">		Name: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">		Age: <span class="string">&quot;52&quot;</span>,</span><br><span class="line">		Id: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data , err := json.Marshal(monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;序列化失败了！&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">		fmt.Println(<span class="string">&quot;序列化成功，并且用了tag标签化！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>在项目开发中，一般接收数据库或者网络输入的Json字串，我们将对其进行反序列化。</p>
<p>在<strong>golang</strong>中，利用<strong>unMarshal</strong>方法对其进行反序列化操作。</p>
<p>先来看看方法的定义：<strong>func  unMarshal([]byte , interface{}) error</strong> </p>
<p>参数：传入一个byte切片，和一个任意类型，其实就是要转化的类型，要跟Json串对应上。</p>
<p>返回值：返回一个error指针，也就是空指针，可以加个判断，若返回的不是nil 则说明反序列化失败！</p>
<p>测试代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="keyword">string</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Id  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unserialization</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;Jack\&quot;,\&quot;age\&quot;:\&quot;52\&quot;,\&quot;Id\&quot;:\&quot;123\&quot;&#125;&quot;</span></span><br><span class="line">	err := json.Unmarshal([]<span class="keyword">byte</span>(str),&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;反序列化失败！&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;反序列化成功&quot;</span>)</span><br><span class="line">		fmt.Println(monster)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	unserialization()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><strong>反序列化成功</strong><br><strong>{Jack 52 123}</strong></p>
<p>在测试代码中，我使用了一个普通的字符串，但是在实际开发项目中，接收的Json字串是来自于网络传输和文件传输。反序列化的底层是利用了反射的原理，反射在后面会学到！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试框架--golang</title>
    <url>/2021/12/05/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引入：根据一个需求，测试完成需求是否正确</p>
<p>根据传统方法：在main函数中运行一次这个方法，看是否与需求完成期望值相同</p>
<p>传统方式的缺点：</p>
<p>​        <strong>①不方便，需要在mian函数中运行，若是代码跑的过程中需要修改，不可能停下来修改main函数。</strong></p>
<p>​        <strong>②不利于管理，若是利用这个方法，我们就会将多个测试函数和测试模块都放在main函数中。</strong></p>
<p>引出：单元测试框架 —— <strong>testing框架</strong></p>
<p>入门案例：利用testing包，在cal_test.go 文件里面写入测试函数，然后对cal.go文件里的函数（模块）进行测试。</p>
<p>在cal_test文件中，代码如图:</p>
<p><img src="/2021/12/05/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/03.png" alt=" "></p>
<p>里面有一个规范函数，*<em>TestAdd(t <em>testing.T){}</em></em></p>
<p>T 是一个结构体，里面含有许多的方法，可以通过接收器（t）来进行调用，比如<strong>t.Fatalf , t.Log</strong>  。</p>
<p>具体查看文档。</p>
<p>在cal.go文件中含有被测试函数，这里具体不多说。</p>
<p>下面来说一说test框架的规范与调用关系。</p>
<p><img src="/2021/12/05/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01.png" alt=" "></p>
<p>如图所示，在test框架中，会引入（寻找）<strong>XXX_test.go</strong> 格式的文件，就把它们作为测试文件——内含测试函数（模块）是否正确的模块，然后在main()中对引入的<strong>XXX_test.go</strong>文件中的<strong>TestXXX格式的函数</strong>进行调用。</p>
<p>上述的格式就是规范，具体调用关系就如图所示。</p>
<p>测试文件可以利用<strong>结构体T</strong>中的方法，进行一些操作，具体看文档。测试结束会输出测试信息。如图：</p>
<p><img src="/2021/12/05/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/02.png" alt=" "></p>
<p>RUN ： 表示运行了什么测试函数。</p>
<p>PASS：表示运行通过的函数。</p>
<p>后面附有测试运行时间！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang--封装</title>
    <url>/2021/12/05/golang%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于一个对象（类型）来说，你想要实现它的方法，就直接调用，内部是不可见的。</p> 

<p>示例：将Account.go的内容封装起来，建立一个包，将方法具体内容写在里面，注意一个规则，在一个包里创建的类型，首字母小写的话，对于其他包不可导出，这就起到了封装作用，在main.go中，无法查看Account的字段。所以只能通过封装的方法来赋值和获取字段内容。</p>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现在是Account.go</span></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Account结构体</span></span><br><span class="line"><span class="comment">//均为小写,通过方法进行访问</span></span><br><span class="line"><span class="comment">//只写方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">string</span>      <span class="comment">// 长度6 - 10</span></span><br><span class="line">	password <span class="keyword">string</span>	 <span class="comment">// 必须是6位</span></span><br><span class="line">	balance <span class="keyword">float64</span>  <span class="comment">// 大于20元</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Setid</span><span class="params">(id <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">len</span> <span class="keyword">int</span> = <span class="built_in">len</span>(id)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> &gt;= <span class="number">6</span> &amp;&amp; <span class="built_in">len</span> &lt;= <span class="number">10</span>&#123;</span><br><span class="line">		a.id = id</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;id长度不合适，拜拜&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SetPassword</span><span class="params">(password <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">len</span> <span class="keyword">int</span> = <span class="built_in">len</span>(password)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> == <span class="number">6</span> &#123;</span><br><span class="line">		a.password = password</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;密码长度不合适，拜拜&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SetBalance</span><span class="params">(money <span class="keyword">float64</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> money &gt; <span class="number">20</span>&#123;</span><br><span class="line">		a.balance = money</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;余额太少，穷B滚蛋！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Getid</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.id</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Getpwd</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.password</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Getbalance</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码就是封装好的方法，方法首字母采用大写字母，所以能被main.go调用，</p>
<p>分别设置字段值和获取字段值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是main.go的代码块</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;awesomeProject/modle&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a model.Account</span><br><span class="line">	a.Setid(<span class="string">&quot;10086&quot;</span>)</span><br><span class="line">	a.SetPassword(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">	a.SetBalance(<span class="number">30</span>)</span><br><span class="line">	fmt.Println(a.Getid(),a.Getpwd(),a.Getbalance())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于main.go的内容来说， var a model.Account 这一行定义一个 model包里面的Account类型的变量，所以a可以访问大写字母开头的方法（如果改为小写字母，则报错无法导出）。</p>
<p>我对于封装的理解还不是很深入，为什么要使用封装？</p>
<p>革命尚未成功，同志仍需努力！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面向对象思想</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>天梯赛校赛感悟</title>
    <url>/2021/12/19/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>18号的天梯赛总算是打完了，最大感想就是没好好刷题，被天梯赛校赛狠狠的虐了一把，最终还是没有触碰到25分的题目，这也许是最大的遗憾，总分拿到了62分，全校排名29，也算是还行，不至于太差，计通院的大佬们确实，太多了，毕竟他们可以天天写。<br>对于本次天梯赛，第二道20分的题目，就差一点就能写出来，可惜了，不然就80分可能就校一了。<br>在做前面10分15分题目时，也是心惊胆战，按道理能AC的，可是败给了细节，有一道15分的只拿下9分，其余的都超时了，花了我好多时间去维护时间复杂度，好在时间没有白费，还是能做出一点分数的。<br>在赛前，我想着保底有100分，可是确实，草率了，20分题目一题没写出来，在最后的半小时还是没能拿到那题20分，还是硬生生被字符串给暴打了，现在想来最大的敌人莫过于字符串。第一道20分的题，想了半天，还是没能AC，用二分法只能拿到8分，确实有点力不从心了，妥妥的算法题，硬是写不出，所以之后的训练，还是不能看答案去解题，自己想，哪怕一题写几小时。<br>21号还有蓝桥杯校赛，估计也要白给了，寒假训练算法就是不能看题解去写题，这是我的一大弱点，必须改正！<br>人生苦短，坚持努力！<br><img src="/2021/12/19/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E6%84%9F%E6%82%9F/02.jpg" alt=" "></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-059 敲笨钟 (20 分)</title>
    <url>/2021/12/15/%E6%95%B2%E7%AC%A8%E9%92%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="L1-059-敲笨钟-20-分-—-C-题解"><a href="#L1-059-敲笨钟-20-分-—-C-题解" class="headerlink" title="L1-059 敲笨钟 (20 分)—-C++题解"></a>L1-059 敲笨钟 (20 分)—-C++题解</h2><p>好久没有刷算法题了，因为18号有天梯赛校赛，就训练了一下PTA上的题目，碰到一道比较简单的基础思维题，现在来看看  </p>
<h3 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h3><p><img src="/2021/12/15/%E6%95%B2%E7%AC%A8%E9%92%9F/01.png" alt=" "></p>
<h3 id="输入输出示例如下"><a href="#输入输出示例如下" class="headerlink" title="输入输出示例如下"></a>输入输出示例如下</h3><p><img src="/2021/12/15/%E6%95%B2%E7%AC%A8%E9%92%9F/02.png" alt=" "></p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题目看着可能有点多，但是仔细分析，其实就是看每一行，分为两句，看每句是否押韵，如果都押韵，那么第二句的最后三个词就变成<strong>敲笨钟</strong>，如果有一句不押韵，就输出<strong>Skipped</strong><br>（1）当遇到逗号和句号，那就判断逗号和句号前几个字母是否为<strong>ong</strong><br>（2）从最后往前遍历，找倒数第三个空格的位置记作<strong>pos</strong>，如果押韵的话从头输出至pos的位置，然后输出敲笨钟即可。<br>这题本身不难，重要考察字符串输入及简单的思维问题<br>下面是AC代码：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n ;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag1 = <span class="number">0</span> , flag2 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span> ; <span class="comment">// 记录第十个空格的下标</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 记录空格数量</span></span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;g&#x27;</span>&amp;&amp;s[i<span class="number">-2</span>]==<span class="string">&#x27;n&#x27;</span>&amp;&amp;s[i<span class="number">-3</span>]==<span class="string">&#x27;o&#x27;</span>)&#123;</span><br><span class="line">                    flag1 = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;g&#x27;</span>&amp;&amp;s[i<span class="number">-2</span>]==<span class="string">&#x27;n&#x27;</span>&amp;&amp;s[i<span class="number">-3</span>]==<span class="string">&#x27;o&#x27;</span>)&#123;</span><br><span class="line">                    flag2 = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">3</span>)&#123;</span><br><span class="line">                    pos = i ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1==<span class="number">1</span>&amp;&amp;flag2==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pos;i++)&#123;</span><br><span class="line">                cout &lt;&lt; s[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; qiao ben zhong.&quot;</span> &lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (flag1==<span class="number">0</span>&amp;&amp;flag2==<span class="number">0</span> || flag1==<span class="number">0</span>&amp;&amp;flag2==<span class="number">1</span> || flag1==<span class="number">1</span>&amp;&amp;flag2==<span class="number">0</span> )&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Skipped&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
</search>
