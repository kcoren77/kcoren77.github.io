<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面向对象初探--基于C++(2)</title>
    <url>/2021/12/07/C++%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="C-继承"><a href="#C-继承" class="headerlink" title="C++继承"></a>C++继承</h2><p>继承是面向对象设计中很重要的一个环节，当要定义一个类时，但是已经存在一个类成员或者类成员函数都是你需要的，那么你再写一个类就会花掉大量功夫，所以引出<strong>继承</strong>的概念。<br>继承——就是在已有类的基础上新建一个类，这个类可以继承<strong>基类</strong>的成员或者成员函数。<br>那么什么是基类呢？基类就是已有的类，也叫<strong>父类</strong>新创建的那个类叫做<strong>派生类</strong>，也叫<strong>子类</strong>。<br>下面来看看一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个shape类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> g)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> width;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::setWidth</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  width = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::setHeight</span><span class="params">(<span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">  height = g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个rectangle继承Shape类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rectangle::getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> width * height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Rectangle ret; <span class="comment">// 一个对象</span></span><br><span class="line">  ret.<span class="built_in">setWidth</span>(<span class="number">10</span>);</span><br><span class="line">  ret.<span class="built_in">setHeight</span>(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; ret.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析代码：<br>先是定义了一个Shape类，然后又定义了一个Rectangle类去继承Shape类，注意继承的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">  <span class="comment">// 内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到写了一个 <strong>public</strong> ，表明是 <strong>public</strong> 类型的继承。<br>问题又来了，那是不是有 <strong>protected</strong> 和<strong>private</strong> 类型的继承呢？<br>答案是肯定的。<br>下面来分析分析三种继承方式的区别：<br><strong>public ：派生类可以访问基类的公有和保护成员，但是不能访问私有成员！</strong><br><strong>protected : 派生类可以继承基类的公有和保护成员，将其变成自己的保护成员！</strong><br><strong>private : 将基类的公有和保护成员变成自己的私有成员！</strong><br>上面就是三种继承方式，可以看出，派生类可以访问基类的<strong>公有成员</strong>和<strong>保护成员</strong>，私有成员神圣不可侵犯！<br>还要注意，一个派生类继承了所有的基类方法，但下列情况除外：<br><strong>基类的构造函数、析构函数和拷贝构造函数。</strong><br><strong>基类的重载运算符</strong><br><strong>基类的友元函数</strong><br>又会有疑问了，什么是重载运算符，什么是友元函数？<br>这个后面再说。<br>先来分析继承的三种方式的特点，结合代码来分析。  </p>
<h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><p>先来看看一个重要的归纳：<br><strong>(1) private成员只能被本类成员和友元访问，不能被其他访问。</strong><br><strong>(2) protected成员可以被派生类访问。</strong>  </p>
<h3 id="public继承"><a href="#public继承" class="headerlink" title="public继承"></a>public继承</h3><p>先看下面一段代码  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">A</span>()&#123;</span><br><span class="line">    a1 = <span class="number">1</span>;</span><br><span class="line">    a2 = <span class="number">2</span>;</span><br><span class="line">    a3 = <span class="number">3</span>;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;    <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> a2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">B</span>(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    a = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;       <span class="comment">//正确，public成员</span></span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; endl;       <span class="comment">//正确，基类的public成员，在派生类中仍是public成员。</span></span><br><span class="line">    cout &lt;&lt; a2 &lt;&lt; endl;       <span class="comment">//正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。</span></span><br><span class="line">    cout &lt;&lt; a3 &lt;&lt; endl;       <span class="comment">//错误，基类的private成员不能被派生类访问。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; b.a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; b.a1 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">  cout &lt;&lt; b.a2 &lt;&lt; endl;   <span class="comment">//错误，类外不能访问protected成员</span></span><br><span class="line">  cout &lt;&lt; b.a3 &lt;&lt; endl;   <span class="comment">//错误，类外不能访问private成员</span></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来分析代码，复习一下，public继承的内容是啥：基类的<strong>public</strong>和<strong>protected</strong>成员在派生类中变成派生类的<strong>public成员</strong> 和 <strong>protected 成员</strong>。<br>然后来看代码，先是定义了一个<strong>A类</strong>，里面的构造函数为4个变量赋值，没毛病吧，注意变量的类型有不相同，在A类中的成员函数 <strong>fun()</strong> 可以轻松访问4个变量，没毛病吧。然后定义一个<strong>B类</strong>，使用public继承，在B类的构造函数里面调用A的构造函数，为啥可以调用呢？因为A类的构造函数是pubic类型的成员函数，注意一个细节，默认的构造函数是private类型的，在这里特意声明为public！回到主题，既然是public类型，那么被B类继承下来，就变成B类的public成员函数了，当然可以调用！<br>然后下面的就不用多说，在B类里面的fun成员函数，可以访问a，a1，a2因为public继承会让基类的public和protected变成自己的public和protected，当然可以访问。<br>main函数中就不多说，public成员可以直接访问，protected和private成员相似，类外不能直接访问！  </p>
<h3 id="protected继承"><a href="#protected继承" class="headerlink" title="protected继承"></a>protected继承</h3><p>其实明白道理就差不多，protected继承，<strong>让基类的public成员和protected成员都变成自己的protected成员</strong>  </p>
<h3 id="private继承"><a href="#private继承" class="headerlink" title="private继承"></a>private继承</h3><p><strong>就是让基类的都变成自己的private成员！</strong>  </p>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>先来明白多继承的概念：<br>多继承就是<strong>一个子类可以有多个父类</strong><br>继承特点上面已经说过了，带入使用即可。<br>基本继承语法如下：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Rectangle使用public继承方式继承Shape类和PainCost类。</strong>  </p>
<p>———结语：我们都不知道未来如何，只能一路前进！———</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象思想</tag>
      </tags>
  </entry>
  <entry>
    <title>Json介绍--基于Golang</title>
    <url>/2021/12/05/Json%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#序列化<br>​        对于跨语言传输数据，可利用一套规范——Json，可以将数据类型给Json序列化，传输到其他地方，再进行反序列化，就可以解析出信息。</p>
<p>​        例如web的b/s应用中，在web服务器中写入（golang规范），进行Json序列化，在传输过程中，会遵守Json规范——这是一套比较科学的规范，将数据传入浏览器，再讲Json字符串进行反序列化，得到原先数据类型的内容，将其规范到使用的语言中。</p>
<p>​        Json序列化其实就是将数据规范成：<strong>键值对</strong>的形式</p>
<p>​        在golang中，序列化需要的包：<strong>encoding/json</strong></p>
<p>​        序列化需要的方法： *<em>json.Marshal(interface{})([]byte , nil <em>error)</em></em> </p>
<p>​        方法说明：参数是一个空接口，就代表可以接收任意类型的数据，返回值为byte类型切片，在实际应用中，大多数要将切片转化成string ， 还返回一个空指针，可以用一个值来接收这个空指针，若返回的非空指针，则说明序列化失败！</p>
<h5 id="Tag的应用"><a href="#Tag的应用" class="headerlink" title="Tag的应用"></a>Tag的应用</h5><p>​        在实际应用中，若要将一个struct Json化，如图Monster结构体</p>
<p><img src="/2021/12/05/Json%E5%BA%8F%E5%88%97%E5%8C%96/01.png" alt=" "></p>
<p>若是将该结构体Json序列化，得到：</p>
<p><strong>{“Name”:”Jack”,”Age”:”52”,”Id”:”123”}</strong></p>
<p>传输进的Json码原样传输，所以我们可以在编码时候加入如图的Tag转化，这样就会替换为json冒号后的东西。</p>
<p><strong>{“name”:”Jack”,”age”:”52”,”Id”:”123”}</strong><br><strong>序列化成功，并且用了tag标签化！</strong></p>
<p>（下面附上golang测试代码）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line"> 	Age <span class="keyword">string</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Id  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	monster = Monster&#123;</span><br><span class="line">		Name: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">		Age: <span class="string">&quot;52&quot;</span>,</span><br><span class="line">		Id: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data , err := json.Marshal(monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;序列化失败了！&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">		fmt.Println(<span class="string">&quot;序列化成功，并且用了tag标签化！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>在项目开发中，一般接收数据库或者网络输入的Json字串，我们将对其进行反序列化。</p>
<p>在<strong>golang</strong>中，利用<strong>unMarshal</strong>方法对其进行反序列化操作。</p>
<p>先来看看方法的定义：<strong>func  unMarshal([]byte , interface{}) error</strong> </p>
<p>参数：传入一个byte切片，和一个任意类型，其实就是要转化的类型，要跟Json串对应上。</p>
<p>返回值：返回一个error指针，也就是空指针，可以加个判断，若返回的不是nil 则说明反序列化失败！</p>
<p>测试代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="keyword">string</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Id  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unserialization</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;Jack\&quot;,\&quot;age\&quot;:\&quot;52\&quot;,\&quot;Id\&quot;:\&quot;123\&quot;&#125;&quot;</span></span><br><span class="line">	err := json.Unmarshal([]<span class="keyword">byte</span>(str),&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;反序列化失败！&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;反序列化成功&quot;</span>)</span><br><span class="line">		fmt.Println(monster)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	unserialization()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><strong>反序列化成功</strong><br><strong>{Jack 52 123}</strong></p>
<p>在测试代码中，我使用了一个普通的字符串，但是在实际开发项目中，接收的Json字串是来自于网络传输和文件传输。反序列化的底层是利用了反射的原理，反射在后面会学到！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试框架--golang</title>
    <url>/2021/12/05/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引入：根据一个需求，测试完成需求是否正确</p>
<p>根据传统方法：在main函数中运行一次这个方法，看是否与需求完成期望值相同</p>
<p>传统方式的缺点：</p>
<p>​        <strong>①不方便，需要在mian函数中运行，若是代码跑的过程中需要修改，不可能停下来修改main函数。</strong></p>
<p>​        <strong>②不利于管理，若是利用这个方法，我们就会将多个测试函数和测试模块都放在main函数中。</strong></p>
<p>引出：单元测试框架 —— <strong>testing框架</strong></p>
<p>入门案例：利用testing包，在cal_test.go 文件里面写入测试函数，然后对cal.go文件里的函数（模块）进行测试。</p>
<p>在cal_test文件中，代码如图:</p>
<p><img src="/2021/12/05/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/03.png" alt=" "></p>
<p>里面有一个规范函数，*<em>TestAdd(t <em>testing.T){}</em></em></p>
<p>T 是一个结构体，里面含有许多的方法，可以通过接收器（t）来进行调用，比如<strong>t.Fatalf , t.Log</strong>  。</p>
<p>具体查看文档。</p>
<p>在cal.go文件中含有被测试函数，这里具体不多说。</p>
<p>下面来说一说test框架的规范与调用关系。</p>
<p><img src="/2021/12/05/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01.png" alt=" "></p>
<p>如图所示，在test框架中，会引入（寻找）<strong>XXX_test.go</strong> 格式的文件，就把它们作为测试文件——内含测试函数（模块）是否正确的模块，然后在main()中对引入的<strong>XXX_test.go</strong>文件中的<strong>TestXXX格式的函数</strong>进行调用。</p>
<p>上述的格式就是规范，具体调用关系就如图所示。</p>
<p>测试文件可以利用<strong>结构体T</strong>中的方法，进行一些操作，具体看文档。测试结束会输出测试信息。如图：</p>
<p><img src="/2021/12/05/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/02.png" alt=" "></p>
<p>RUN ： 表示运行了什么测试函数。</p>
<p>PASS：表示运行通过的函数。</p>
<p>后面附有测试运行时间！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang--封装</title>
    <url>/2021/12/05/golang%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于一个对象（类型）来说，你想要实现它的方法，就直接调用，内部是不可见的。</p> 

<p>示例：将Account.go的内容封装起来，建立一个包，将方法具体内容写在里面，注意一个规则，在一个包里创建的类型，首字母小写的话，对于其他包不可导出，这就起到了封装作用，在main.go中，无法查看Account的字段。所以只能通过封装的方法来赋值和获取字段内容。</p>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现在是Account.go</span></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Account结构体</span></span><br><span class="line"><span class="comment">//均为小写,通过方法进行访问</span></span><br><span class="line"><span class="comment">//只写方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">string</span>      <span class="comment">// 长度6 - 10</span></span><br><span class="line">	password <span class="keyword">string</span>	 <span class="comment">// 必须是6位</span></span><br><span class="line">	balance <span class="keyword">float64</span>  <span class="comment">// 大于20元</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Setid</span><span class="params">(id <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">len</span> <span class="keyword">int</span> = <span class="built_in">len</span>(id)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> &gt;= <span class="number">6</span> &amp;&amp; <span class="built_in">len</span> &lt;= <span class="number">10</span>&#123;</span><br><span class="line">		a.id = id</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;id长度不合适，拜拜&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SetPassword</span><span class="params">(password <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">len</span> <span class="keyword">int</span> = <span class="built_in">len</span>(password)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> == <span class="number">6</span> &#123;</span><br><span class="line">		a.password = password</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;密码长度不合适，拜拜&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SetBalance</span><span class="params">(money <span class="keyword">float64</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> money &gt; <span class="number">20</span>&#123;</span><br><span class="line">		a.balance = money</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;余额太少，穷B滚蛋！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Getid</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.id</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Getpwd</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.password</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Getbalance</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码就是封装好的方法，方法首字母采用大写字母，所以能被main.go调用，</p>
<p>分别设置字段值和获取字段值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是main.go的代码块</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;awesomeProject/modle&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a model.Account</span><br><span class="line">	a.Setid(<span class="string">&quot;10086&quot;</span>)</span><br><span class="line">	a.SetPassword(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">	a.SetBalance(<span class="number">30</span>)</span><br><span class="line">	fmt.Println(a.Getid(),a.Getpwd(),a.Getbalance())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于main.go的内容来说， var a model.Account 这一行定义一个 model包里面的Account类型的变量，所以a可以访问大写字母开头的方法（如果改为小写字母，则报错无法导出）。</p>
<p>我对于封装的理解还不是很深入，为什么要使用封装？</p>
<p>革命尚未成功，同志仍需努力！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面向对象思想</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象初探--基于C++</title>
    <url>/2021/12/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="c-类"><a href="#c-类" class="headerlink" title="c++类"></a>c++类</h1><p>​    话不多说，看一段代码：</p>
<p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该段代码中，使用<strong>class</strong>创建一个<strong>Box类</strong>，可以初始化一个<strong>对象</strong>：</p>
<p>​    <strong>Box Box1</strong></p>
<p>非常简单的初始化了一个<strong>Box1对象</strong>。</p>
<p>这个时候，Box1就可以用<strong>（.）成员访问运算符</strong>访问<strong>public</strong>里面的<strong>成员</strong>，对于<strong>private</strong>和<strong>protect</strong>的成员，不能用（.）进行访问。注意一点，成员默认为<strong>private</strong>的。</p>
<p>具体如何访问，后面再记！</p>
<h1 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h1><p>​    首先，理解什么是类成员函数，既然有“成员”两个字，那么肯定是属于类的一个成员，就跟定义类中其他成员一样。</p>
<p>​    类成员函数可以操作类的对象，也可以访问对象的成员。</p>
<p>​    举个例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;         <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;        <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;         <span class="comment">// 高度</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 返回体积</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类中声明了一个getVolume函数，既然是在类里面，那肯定是成员函数。下面来创建一个对象：</p>
<p>​                                        <strong>Box Box1</strong> </p>
<p>Box1就可以使用这个成员函数，怎么使用呢？用成员访问运算符</p>
<p>（跟上面说的 public 成员一样的）。</p>
<p>​                                   <strong>Box1.getVolume()</strong> </p>
<p>就可以使用这个成员函数了。</p>
<p>这个成员函数只有声明，没有定义函数体。有两种方法：</p>
<p>第一种：在类里面定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接写函数体内容就完事，注意：上面说过，成员函数是可以访问对象的成员的哦！</p>
<p>第二种：在类外面定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个形式了吧，一定要写类名！然后用<strong>范围解析运算符 ::</strong></p>
<p>进行定义！</p>
<p>然后发现长宽高都没有定义啊，return了个寂寞。</p>
<p>其实可以写多个类成员函数，进行初始化赋值。</p>
<p>后面有个简便初始化赋值的方法——构造函数。（后面再说）</p>
<h1 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h1><p>​    类访问修饰符分为三个：<strong>public private protected</strong> </p>
<p>​    先说第一个 <strong>public</strong> ：</p>
<p>这个比较熟悉，可以被外部访问，那么什么算是外部呢？其实就是可以被对象直接使用，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在main函数中声明一个对象  Box Box1 。</p>
<p>那么要对成员进行初始化，两个方法：要么写一个类成员函数，对其进行赋值，还有一种，重点：直接进行赋值。</p>
<p>就是 **Box1.length = 2.0  ……**直接进行访问，因为length是开放的。</p>
<p>​    然后就是 <strong>private ：</strong></p>
<p>只有类和友元函数能访问私有成员。</p>
<p>就是说不能被对象在外部直接访问，但是可以用公有的成员函数进行访问赋值。（为什么要强调公有呢？因为公有才可以调用，如果设置私有成员函数，那还怎么调用它？）</p>
<p>​    然后就是<strong>protected ：</strong></p>
<p>这个和私有成员差不多，有一点：其<strong>派生类可以访问！</strong></p>
<p>举个栗子（上代码）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">double</span> width;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallBox</span>:</span>Box <span class="comment">// SmallBox 是派生类</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setSmallWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getSmallWidth</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个Box 类，派生了一个SmallBox类</p>
<p>Box有个protected成员，SmallBox有两个成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">SmallBox::getSmallWidth</span><span class="params">(``<span class="keyword">void</span>``)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> width ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmallBox::setSmallWidth</span><span class="params">( ``<span class="keyword">double</span>` `wid )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  width = wid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看main函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   SmallBox box;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 使用成员函数设置宽度</span></span><br><span class="line">   box.<span class="built_in">setSmallWidth</span>(<span class="number">5.0</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Width of box : &quot;</span>&lt;&lt; box.<span class="built_in">getSmallWidth</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个SmallBox类的对象box，box能访问父类里的width，进行赋值，这就是一个很好的例子。想一想，能不能直接访问呢？</p>
<p>就是 box.width = 5.0  ，动手试一试。</p>
<p>运行结果是不行的，为什么不行，不是可以访问吗？</p>
<p><strong>忽略了一点，protected是跟private相似，回顾一下private的访问方法，只能被类和成员函数访问，既然SmallBox继承了Box，那么Box就继承了父类的属性，SmallBox的成员函数就能访问private成员，即访问父类的类似于private的protected成员！</strong></p>
<h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><p>​    构造函数属于类的一种特殊的成员函数，<strong>与类同名</strong>，在创建新对象的时候会调用，没有返回值，可以有参数。带参数的构造函数一般用于类成员的初始化。</p>
<p>​    对于析构函数，一般在删除对象的时候会执行，析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>
<p>​    如果程序里没有构造函数和析构函数，编译器在编译的时候会自动生成构造函数和析构函数，只是函数内没有任何操作。</p>
<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>​    看下方一段代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Getlentgh</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="built_in">Line</span>(<span class="keyword">int</span> len);</span><br><span class="line">	<span class="built_in">Line</span>(<span class="keyword">const</span> Line&amp; obj);</span><br><span class="line">	~<span class="built_in">Line</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span>* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">int</span> len) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用构造函数为指针分配内存!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">const</span> Line &amp;obj) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数为指针分配内存！&quot;</span> &lt;&lt; endl;;</span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = *obj.ptr + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~<span class="built_in">Line</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;释放内存&quot;</span> &lt;&lt; *ptr &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Line::Getlentgh</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Line obj)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; obj.<span class="built_in">Getlentgh</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Line <span class="title">line1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	Line line2 = line1; <span class="comment">// 这里会调用拷贝构造函数</span></span><br><span class="line">	<span class="built_in">display</span>(line1);</span><br><span class="line">	<span class="built_in">display</span>(line2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是输出：</p>
<p><img src="/2021/12/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%8E%A2/01.png" alt=" "></p>
<p>说说我的分析：</p>
<p>​    在main函数内，创建了一个<strong>line1对象</strong>，那么，肯定会先调用构造函数，因为构造函数会在创建新对象的时候调用，所以输出的第一行是<strong>line1的构造函数</strong>执行了。</p>
<p>​    现在看后面的拷贝构造函数调用，是怎么回事呢？先来看看什么是拷贝构造。</p>
<p>​    <strong>拷贝构造函数</strong>是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于(被调用于)：</p>
<p>​    <strong>① 通过使用另一个同类型的对象来初始化新创建的对象。</strong></p>
<p>​    <strong>② 复制对象把它作为参数传递给函数。</strong></p>
<p>​    <strong>③ 复制对象，并从函数返回这个对象。</strong></p>
<p>拷贝构造函数的主体为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">classname</span> (<span class="keyword">const</span> classname &amp;obj) &#123;</span><br><span class="line">   <span class="comment">// 构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    对于拷贝构造函数的用途，很显然，该段示例中用了两种——①和②，且听我慢慢道来。</p>
<p>​    既然说可以通过一个同类型对象初始化新创建的对象，那么在代码中，利用<strong>line1</strong> 给 <strong>line2</strong> 进行了初始化，那么肯定会调用一次拷贝构造函数，所以输出的第二行就是这么来的。</p>
<p>​    再看输出的第三行的拷贝构造函数，怎么来的呢？</p>
<p>​    因为将一个对象当成形参传递给函数时，也会调用拷贝构造函数，所以在main函数中，**display(line1)**就会调用拷贝构造函数，就是这么来的，传递给函数后，由于调用了拷贝构造函数，它的值加一，所以会打印出11。</p>
<p>​    可能又会问，不是调用了两次吗，为什么不是12呢？</p>
<p>​    <strong>因为第一次调用，是给line2对象进行初始化，所以line2的初始是10，然后执行的是line2的拷贝构造函数，line2的变成11，这时候line1的还是10，当第二次执行拷贝构造函数的时候，就是把line1作为参数传进display，所以第二次执行的是line1的拷贝构造函数。</strong></p>
<p>​    然后display()执行结束，把形参(局部)line1给释放掉了，所以会调用局部的line1的析构函数。</p>
<p>​    然后又是一个执行拷贝构造函数，不用多说，肯定是line2作为参数传进display(),给调用了一次，还记得初始化调用了一次吗，那时候为11，这时候又调用，那就为12了，然后打印12出来，释放参数。</p>
<p>​    重点来了，为什么最后两个释放呢？为什么一个11，一个10？</p>
<p>​    先知道，肯定是return 0，结束了，然后执行了line1和line2的析构函数，这个没毛病吧？那个值是怎么回事呢？</p>
<p>​    先给个答案，11的那个是line2 的，10的那个是line1 的。为什么呢？</p>
<p>​    <strong>因为在初始化line2的时候，调用了一次拷贝构造函数，那时候line2的变成了11，注意，没有被释放！只释放了变成12的那次！但是line1的是通过作为参数的方式传进函数然后执行拷贝构造函数的，会被释放掉，所以还是初始值10。</strong></p>
<p>​    <strong>SO，大体就是这样，所以要牢记调用拷贝构造函数的条件！注意第三点：对象作为函数返回值也会调用一次！</strong></p>
<p>​    拷贝也有深拷贝和浅拷贝，后面再说！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象思想</tag>
      </tags>
  </entry>
</search>
