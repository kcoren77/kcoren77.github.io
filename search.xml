<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2021/12/04/Channal%E4%BD%BF%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="chnnal信道使用机制"><a href="#chnnal信道使用机制" class="headerlink" title="chnnal信道使用机制"></a>chnnal信道使用机制</h1><p>​    在解决资源争夺方面，介绍两种方法，一种是加锁，另一种就是使用<strong>chnnal</strong>。</p>
<p>​    chnnal基本的声明 ： <strong>var 变量名 chan 类型</strong>  </p>
<p>​    chnnal 本质是一个队列，遵循先进先出。在初始化时候，需要用make函数进行初始化。<strong>chnnal是一种引用类型</strong>。</p>
<p>​    基本写入操作： 例如声明了一个变量intchan，var intchan chan int ， 使用make初始化：intchan = make(chan int , 10) 容量为10可以将<strong>常量</strong>或者<strong>变量</strong>写入intchan。</p>
<p>​    如： intChan&lt;-10  </p>
<p>​    取出值： num :=  &lt;-intchan </p>
<p>​    遵循先进先出，所以取出来也遵循。</p>
<h2 id="信道的分类"><a href="#信道的分类" class="headerlink" title="信道的分类"></a>信道的分类</h2><p>​    <strong>无缓冲通道：</strong>在make时不需要写容量，无缓冲信道在两个协程间传递数据，当协程1发送数据时候，协程二就会阻塞，直到协程二读取此信道的数据。当然，在主线程上开启一个协程，向信道内写入数据，在主线程上读取的话，主线程会很快，嗖的一下，但是，主线程会阻塞在读取值的那一行代码，等到写入值的那一个协程成功写入的时候，阻塞停止，主线程成功读取到值。（注意：写入的协程要在读取之上，否则死锁）。</p>
<p>通俗来讲，无缓冲信道，写一个才能读取一个，不能进行数据储存，写入和读取时候都会让另一个协程进入阻塞状态。</p>
<p>​    <strong>有缓冲通道：</strong>本质上就是一个队列，可以存储数据，可以写入和读取。在make时需要进行初始化时候要进行容量分配。</p>
<p>无缓冲信道在<strong>写入</strong>和<strong>读取</strong>时候会发生阻塞，那么缓冲信道什么时候会发生阻塞呢？它是有容量的，也就是说，当写入的数据超过其容量的时候，它就会发生阻塞，将数据读取出去后，才可以继续写入。只要缓冲信道里面有数据，读取协程就可以对其进行读取数据。一开始缓冲信道里面没有数据，读取协程就会出现阻塞，直到写入协程写入数据，所以说<strong>写入慢读取快</strong>或者<strong>写入快读取慢</strong>都是可以存在的，不会发生死锁。</p>
<h3 id="信道的注意事项"><a href="#信道的注意事项" class="headerlink" title="信道的注意事项"></a>信道的注意事项</h3><p>​    信道可以close()，当关闭后，只能对其进行读取而不能继续写入。</p>
<p>​    在主线程中开启一个协程，协程对一个无缓冲通道进行写入操作，并在主线程中进行遍历。下面是我的分析：</p>
<p>​    在协程中，利用for循环对其写入数据，主线程中用for—range将其读取，程序开始时，主线程非常快，嗖的一下，但是，会阻塞在for—range中，因为读取不到，所以只能等待协程写入数据，协程有点慢，写入一个后，然后阻塞结束，读取并打印出来，反复进行，直到最后，写入完了，怎么办，必须得close，为什么要close呢，我们知道，不close的话会死锁，<strong>因为当一个协程从没有数据的信道中读取数据，并且这个信道没有被关闭时，就会出现死锁，</strong>那么就简单了，当写入的for循环退出后，如果不关闭的话，那么主线程的for–range还会继续运行，就会读取不到数据，就会出现死锁。</p>
<p>​    我们知道，close close ，但是什么时候要close 呢？ 对于上面的例子我很容易知道什么时候关闭，不就是写入完毕时候关掉嘛，但是在大项目中，比如用多个协程来写入读取数据呢？(假装这是个大项目)，可以……..来解决。</p>
<p>​    介绍一种用 <strong>select</strong> 解决的方法 ， 举个栗子：利用两个协程对两个通道进行写入操作，怎么知道写入完了呢？下面是解决方法，我不用for – range 进行读取 ，因为没关闭懂吧。</p>
<p>![image-20211114174834579](C:\Users\The shy\AppData\Roaming\Typora\typora-user-images\image-20211114174834579.png)</p>
<p>我的分析：这里有个for循环阻塞主线程，然后里面用<strong>select</strong>，case XX 对其进行读取，当读取不了的时候，那么当然写入肯定完了，然后return 直接了结主线程，如果用break的话是退不出for循环的！这就很完美的读取了数据并且避开了不知何时关闭管道的情况，肥肠好用！</p>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/12/03/test/</url>
    <content><![CDATA[<h1 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h1><p>​        对于跨语言传输数据，可利用一套规范——Json，可以将数据类型给Json序列化，传输到其他地方，再进行反序列化，就可以解析出信息。</p>
<p>​        例如web的b/s应用中，在web服务器中写入（golang规范），进行Json序列化，在传输过程中，会遵守Json规范——这是一套比较科学的规范，将数据传入浏览器，再讲Json字符串进行反序列化，得到原先数据类型的内容，将其规范到使用的语言中。</p>
<p>​        Json序列化其实就是将数据规范成：<strong>键值对</strong>的形式</p>
<p>​        在golang中，序列化需要的包：<strong>encoding/json</strong></p>
<p>​        序列化需要的方法： *<em>json.Marshal(interface{})([]byte , nil <em>error)</em></em> </p>
<p>​        方法说明：参数是一个空接口，就代表可以接收任意类型的数据，返回值为byte类型切片，在实际应用中，大多数要将切片转化成string ， 还返回一个空指针，可以用一个值来接收这个空指针，若返回的非空指针，则说明序列化失败！</p>
<h5 id="Tag的应用"><a href="#Tag的应用" class="headerlink" title="Tag的应用"></a>Tag的应用</h5><p>​        在实际应用中，若要将一个struct Json化，如图Monster结构体</p>
<p>![image-20211110165821114](C:\Users\The shy\AppData\Roaming\Typora\typora-user-images\image-20211110165821114.png)</p>
<p>若是将该结构体Json序列化，得到：</p>
<p><strong>{“Name”:”Jack”,”Age”:”52”,”Id”:”123”}</strong></p>
<p>传输进的Json码原样传输，所以我们可以在编码时候加入如图的Tag转化，这样就会替换为json冒号后的东西。</p>
<p><strong>{“name”:”Jack”,”age”:”52”,”Id”:”123”}</strong><br><strong>序列化成功，并且用了tag标签化！</strong></p>
<p>（下面附上golang测试代码）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line"> 	Age <span class="keyword">string</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Id  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	monster = Monster&#123;</span><br><span class="line">		Name: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">		Age: <span class="string">&quot;52&quot;</span>,</span><br><span class="line">		Id: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data , err := json.Marshal(monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;序列化失败了！&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">		fmt.Println(<span class="string">&quot;序列化成功，并且用了tag标签化！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>在项目开发中，一般接收数据库或者网络输入的Json字串，我们将对其进行反序列化。</p>
<p>在<strong>golang</strong>中，利用<strong>unMarshal</strong>方法对其进行反序列化操作。</p>
<p>先来看看方法的定义：<strong>func  unMarshal([]byte , interface{}) error</strong> </p>
<p>参数：传入一个byte切片，和一个任意类型，其实就是要转化的类型，要跟Json串对应上。</p>
<p>返回值：返回一个error指针，也就是空指针，可以加个判断，若返回的不是nil 则说明反序列化失败！</p>
<p>测试代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="keyword">string</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Id  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unserialization</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;Jack\&quot;,\&quot;age\&quot;:\&quot;52\&quot;,\&quot;Id\&quot;:\&quot;123\&quot;&#125;&quot;</span></span><br><span class="line">	err := json.Unmarshal([]<span class="keyword">byte</span>(str),&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;反序列化失败！&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;反序列化成功&quot;</span>)</span><br><span class="line">		fmt.Println(monster)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	unserialization()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><strong>反序列化成功</strong><br><strong>{Jack 52 123}</strong></p>
<p>在测试代码中，我使用了一个普通的字符串，但是在实际开发项目中，接收的Json字串是来自于网络传输和文件传输。反序列化的底层是利用了反射的原理，反射在后面会学到！</p>
]]></content>
  </entry>
</search>
